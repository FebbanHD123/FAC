package de.febanhd.anticrash.utils;

import com.comphenix.protocol.reflect.FieldAccessException;
import com.comphenix.protocol.wrappers.nbt.NbtBase;
import com.comphenix.protocol.wrappers.nbt.NbtCompound;
import com.comphenix.protocol.wrappers.nbt.NbtFactory;
import com.comphenix.protocol.wrappers.nbt.NbtList;
import com.google.common.collect.Lists;
import com.google.common.io.BaseEncoding;
import de.febanhd.anticrash.checks.CheckResult;
import de.febanhd.anticrash.config.ConfigCache;
import net.minecraft.server.v1_8_R3.Block;
import net.minecraft.server.v1_8_R3.IBlockData;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import net.minecraft.server.v1_8_R3.NBTTagList;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

public class ExploitCheckUtils {

    public static CheckResult isInvalidBookTag(NBTTagCompound tag) {
        if(tag == null)
            return new CheckResult.Negative("");

        NBTTagList pagesNBTList = tag.getList("pages", 8);
        ArrayList<String> pages = Lists.newArrayList();

        for(int i = 0; i < pagesNBTList.size(); i++) {
            pages.add(pagesNBTList.getString(i));
        }

        int pageLimit = ConfigCache.getInstance().getValue("bookcheck.page_limit", 50, Integer.class);
        int pageByteLimit = ConfigCache.getInstance().getValue("bookcheck.page_byte_limit", 750, Integer.class);
        int byteLimit = ConfigCache.getInstance().getValue("bookcheck.byte_limit", 38000, Integer.class);
        int maxAllowedChars = ConfigCache.getInstance().getValue("bookcheck.page_chars", 300, Integer.class);

        if(pages.size() > pageLimit) {
            return new CheckResult.Positive("Too many pages (> " + pageLimit + ")");
        }

        StringBuilder builder = new StringBuilder();
        int bookContentBytes = 0;
        for(String page : pages) {
            int pageBytes = page.getBytes(StandardCharsets.UTF_8).length;
            bookContentBytes += pageBytes;

            if(pageBytes > pageByteLimit) {
                return new CheckResult.Positive("Too many bytes per page (> " + pageByteLimit + ")");
            }

            builder.append(page);
        }
        if(bookContentBytes > byteLimit) {
            return new CheckResult.Positive("Too many bytes (> " + byteLimit + ")");
        }
        String bookContent = builder.toString();
        char[] chars = bookContent.toCharArray();

        maxAllowedChars *= pages.size();

        if(chars.length > maxAllowedChars) {
            return new CheckResult.Positive("Too many characters for " + pages.size() + " page/s (> " + maxAllowedChars + ")");
        }

        return new CheckResult.Negative("");
    }

    public static CheckResult isValidSpawnerEntityTag(final NBTTagCompound tag) {

        int spawnRange = tag.getInt("SpawnRange");
        int requiredPlayerRange = tag.getInt("RequiredPlayerRange");
        int maxNearbyEntities = tag.getInt("MaxNearbyEntities");

        int spawnCount = tag.getInt("SpawnCount");

        int delay = tag.getInt("Delay");
        int maxSpawnDelay = tag.getInt("MaxSpawnDelay");
        int minSpawnDelay = tag.getInt("MinSpawnDelay");

        if(spawnRange > Short.MAX_VALUE || requiredPlayerRange > Short.MAX_VALUE || maxNearbyEntities > Short.MAX_VALUE ||
                spawnCount > Short.MAX_VALUE || delay > Short.MAX_VALUE || maxSpawnDelay > Short.MAX_VALUE || minSpawnDelay > Short.MAX_VALUE) {
            return new CheckResult.Negative("Invalid spawner arguments (Too height)");
        }

        if (tag.hasKeyOfType("SpawnData", 10)) {
            CheckResult result = isValidSpawnData(tag.getCompound("SpawnData"));
            if(!result.check())
                return result;
        }

        int maxAllowedSpawnRange = ConfigCache.getInstance().getValue("nbtcheck.spawner.maxSpawnRange", 20, Integer.class);
        int maxAllowedSpawnDelay = ConfigCache.getInstance().getValue("nbtcheck.spawner.maxSpawnDelay", 1000, Integer.class);
        int maxAllowedSpawnCount = ConfigCache.getInstance().getValue("nbtcheck.spawner.maxSpawnCount", 30, Integer.class);
        int maxAllowedRequiredPlayerRange = ConfigCache.getInstance().getValue("nbtcheck.spawner.maxRequiredPlayerRange", 16, Integer.class);

        if(spawnRange > maxAllowedSpawnRange)
            return new CheckResult.Negative("Too high SpawnRange (> " + maxAllowedSpawnRange + ")");

        if(maxSpawnDelay > maxAllowedSpawnDelay) {
            return new CheckResult.Negative("Too high SpawnDelay (> " + maxAllowedSpawnDelay + ")");
        }

        if(spawnCount > maxAllowedSpawnCount)
            return new CheckResult.Negative("Too high SpawnCount (> " + maxAllowedSpawnCount + ")");

        if(requiredPlayerRange > maxAllowedRequiredPlayerRange)
            return new CheckResult.Negative("RequiredPlayerRange is too high (> " + maxAllowedRequiredPlayerRange + ")");

        return new CheckResult.Positive("");
    }

    public static CheckResult isValidSpawnData(NBTTagCompound tag) {
        try {
            IBlockData blockData = null;
            int blockDataAmount = 0;

            int i = tag.getByte("Data") & 255;
            if (tag.hasKeyOfType("Block", 8)) {
                blockData = Block.getByName(tag.getString("Block")).fromLegacyData(i);
                blockDataAmount++;
            }
            if (tag.hasKeyOfType("TileID", 99)) {
                blockData = Block.getById(tag.getInt("TileID")).fromLegacyData(i);
                blockDataAmount++;
            }
            if (tag.hasKey("Tile")) {
                blockData = Block.getById(tag.getByte("Tile") & 255).fromLegacyData(i);
                blockDataAmount++;
            }
            if (blockDataAmount > 0) {
                if (blockDataAmount > 1) {
                    return new CheckResult.Negative("Too many block datas (" + blockDataAmount + ")");
                }
            }
        }catch (Exception e) {
            return new CheckResult.Negative("Can't find block from block data");
        }
        return new CheckResult.Positive("");
    }

    public static CheckResult isValidMap(NBTTagCompound nbtTag) {
        try {
            int range = nbtTag.getInt("range");
            int maxRange = ConfigCache.getInstance().getValue("nbtcheck.map.maxRange", 15, Integer.class);

            if(range > maxRange) {
                return new CheckResult.Negative("Too high range (> " + maxRange + ")");
            }

        }catch (Exception e) {
            return new CheckResult.Negative("Exception while checking map. (Invalid datas)");
        }
        return new CheckResult.Positive();
    }

    /*
    * This check is not mine! Its from https://www.spigotmc.org/resources/skull-exploit-fix.26099/
    * Thanks :D
    */
    public static CheckResult isInvalidSkull(NBTTagCompound nbtTag) {
        NbtCompound root = NbtFactory.fromNMSCompound(nbtTag);
        String ownerTag;
        if (root.containsKey("SkullOwner")) {
            ownerTag = "SkullOwner"; // item
        } else if (root.containsKey("Owner")) {
            ownerTag = "Owner"; // block
        } else {
            return new CheckResult.Negative(); // neither ==> not an exploit
        }
        NbtCompound skullOwner = root.getCompound(ownerTag);
        if (skullOwner.containsKey("Properties")) {
            NbtCompound properties = skullOwner.getCompound("Properties");
            if (properties.containsKey("textures")) {
                NbtList<NbtBase> textures;
                try {
                    textures = properties.getList("textures");
                } catch (FieldAccessException e) {
                    return new CheckResult.Positive("Cannot load textures from Skull.");
                }
                for (NbtBase texture : textures.asCollection()) {
                    if (texture instanceof NbtCompound) {
                        // Check for value
                        if (((NbtCompound) texture).containsKey("Value")) {
                            if (((NbtCompound) texture).getString("Value").trim().length() > 0) {
                                // Check json
                                try {
                                    String decoded = new String(BaseEncoding.base64().decode(((NbtCompound) texture).getString("Value")));
                                    JSONObject object = (JSONObject) new JSONParser().parse(decoded);
                                    if (object.containsKey("textures")) {
                                        object = (JSONObject) object.get("textures");
                                    }
                                    if (object.containsKey("SKIN")) {
                                        object = (JSONObject) object.get("SKIN");
                                    }
                                    if (!object.containsKey("url")) {
                                        root.remove(ownerTag);
                                        return new CheckResult.Positive("Skull-Tag contains no url");
                                    }
                                    if (((String) object.get("url")).trim().length() == 0) {
                                        root.remove(ownerTag);
                                        return new CheckResult.Positive("Skull-Tag contains invalid url");
                                    }
                                    return new CheckResult.Negative();
                                } catch (Exception e) {
                                    // Decode failed
                                    root.remove(ownerTag);
                                    return new CheckResult.Positive("Cannot decode Skull-Tag");
                                }
                            } else {
                                root.remove(ownerTag);
                                return new CheckResult.Positive("Skull-Tag contains invalid value");
                            }
                        } else {
                            root.remove(ownerTag);
                            return new CheckResult.Positive("Skull-Tag contains no value");
                        }
                    }
                }
            }
        }
        return new CheckResult.Negative();
    }

}
