package de.febanhd.anticrash.utils;

import com.google.common.collect.Lists;
import de.febanhd.anticrash.checks.CheckResult;
import de.febanhd.anticrash.config.ConfigCach;
import net.minecraft.server.v1_8_R3.Block;
import net.minecraft.server.v1_8_R3.IBlockData;
import net.minecraft.server.v1_8_R3.NBTTagCompound;
import net.minecraft.server.v1_8_R3.NBTTagList;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;

public class ExploitCheckUtils {

    public static CheckResult isInvalidBookTag(NBTTagCompound tag) {
        if(tag == null)
            return new CheckResult.Negative("");

        NBTTagList pagesNBTList = tag.getList("pages", 8);
        ArrayList<String> pages = Lists.newArrayList();

        for(int i = 0; i < pagesNBTList.size(); i++) {
            pages.add(pagesNBTList.getString(i));
        }

        int pageLimit = ConfigCach.getInstance().getValue("bookcheck.page_limit", 50, Integer.class);
        int pageByteLimit = ConfigCach.getInstance().getValue("bookcheck.page_byte_limit", 350, Integer.class);
        int byteLimit = ConfigCach.getInstance().getValue("bookcheck.byte_limit", 16000, Integer.class);
        int maxAllowedChars = ConfigCach.getInstance().getValue("bookcheck.page_chars", 255, Integer.class);

        if(pages.size() > pageLimit) {
            return new CheckResult.Positive("Too many pages (> " + pageLimit + ")");
        }

        StringBuilder builder = new StringBuilder();
        int bookContentBytes = 0;
        for(String page : pages) {
            int pageBytes = page.getBytes(StandardCharsets.UTF_8).length;
            bookContentBytes += pageBytes;

            if(pageBytes > pageByteLimit) {
                return new CheckResult.Positive("Too many bytes per page (> " + pageByteLimit + ")");
            }

            builder.append(page);
        }
        if(bookContentBytes > byteLimit) {
            return new CheckResult.Positive("Too many bytes (> " + byteLimit + ")");
        }
        String bookContent = builder.toString();
        char[] chars = bookContent.toCharArray();

        if(chars.length > maxAllowedChars) {
            return new CheckResult.Positive("Too many characters for " + pages.size() + " page/s (> " + maxAllowedChars + ")");
        }

        return new CheckResult.Negative("");
    }

    public static CheckResult isValidSpawnerEntityTag(final NBTTagCompound tag) {

        int spawnRange = tag.getInt("SpawnRange");
        int requiredPlayerRange = tag.getInt("RequiredPlayerRange");
        int maxNearbyEntities = tag.getInt("MaxNearbyEntities");

        int spawnCount = tag.getInt("SpawnCount");

        int delay = tag.getInt("Delay");
        int maxSpawnDelay = tag.getInt("MaxSpawnDelay");
        int minSpawnDelay = tag.getInt("MinSpawnDelay");

        if(spawnRange > Short.MAX_VALUE || requiredPlayerRange > Short.MAX_VALUE || maxNearbyEntities > Short.MAX_VALUE ||
                spawnCount > Short.MAX_VALUE || delay > Short.MAX_VALUE || maxSpawnDelay > Short.MAX_VALUE || minSpawnDelay > Short.MAX_VALUE) {
            return new CheckResult.Negative("Invalid spawner arguments (Too height)");
        }

        if (tag.hasKeyOfType("SpawnData", 10)) {
            CheckResult result = isValidSpawnData(tag.getCompound("SpawnData"));
            if(!result.check())
                return result;
        }

        int maxAllowedSpawnRange = ConfigCach.getInstance().getValue("nbtcheck.spawner.maxSpawnRange", 20, Integer.class);
        int maxAllowedSpawnDelay = ConfigCach.getInstance().getValue("nbtcheck.spawner.maxSpawnDelay", 1000, Integer.class);
        int maxAllowedSpawnCount = ConfigCach.getInstance().getValue("nbtcheck.spawner.maxSpawnCount", 30, Integer.class);
        int maxAllowedRequiredPlayerRange = ConfigCach.getInstance().getValue("nbtcheck.spawner.maxRequiredPlayerRange", 16, Integer.class);

        if(spawnRange > maxAllowedSpawnRange)
            return new CheckResult.Negative("Too high SpawnRange (> " + maxAllowedSpawnRange + ")");

        if(maxSpawnDelay > maxAllowedSpawnDelay) {
            return new CheckResult.Negative("Too high SpawnDelay (> " + maxAllowedSpawnDelay + ")");
        }

        if(spawnCount > maxAllowedSpawnCount)
            return new CheckResult.Negative("Too high SpawnCount (> " + maxAllowedSpawnCount + ")");

        if(requiredPlayerRange > maxAllowedRequiredPlayerRange)
            return new CheckResult.Negative("RequiredPlayerRange is too high (> " + maxAllowedRequiredPlayerRange + ")");

        return new CheckResult.Positive("");
    }

    public static CheckResult isValidSpawnData(NBTTagCompound tag) {
        try {
            IBlockData blockData = null;
            int blockDataAmount = 0;

            int i = tag.getByte("Data") & 255;
            if (tag.hasKeyOfType("Block", 8)) {
                blockData = Block.getByName(tag.getString("Block")).fromLegacyData(i);
                blockDataAmount++;
            }
            if (tag.hasKeyOfType("TileID", 99)) {
                blockData = Block.getById(tag.getInt("TileID")).fromLegacyData(i);
                blockDataAmount++;
            }
            if (tag.hasKey("Tile")) {
                blockData = Block.getById(tag.getByte("Tile") & 255).fromLegacyData(i);
                blockDataAmount++;
            }
            if (blockDataAmount > 0) {
                if (blockDataAmount > 1) {
                    return new CheckResult.Negative("Too many block datas (" + blockDataAmount + ")");
                }
            }
        }catch (Exception e) {
            return new CheckResult.Negative("Can't find block from block data");
        }
        return new CheckResult.Positive("");
    }
}
